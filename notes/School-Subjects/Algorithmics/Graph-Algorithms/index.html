<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="#algo
Breadth First Search (BFS) #card BFS is a graph traversal algorithm that visits all neighbours of a source node, and keeps visiting neighbours of neighbours until the entire graph is traversed."><title>Graph Algorithms</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://garv-shah.github.io/brain/icon.png><link href=https://garv-shah.github.io/brain/styles.547fb332ce56cdc523146ba5ede80d7f.min.css rel=stylesheet><link href=https://garv-shah.github.io/brain/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://garv-shah.github.io/brain/js/darkmode.d2f9c03bc6718238c95256784ad55a40.min.js></script>
<script src=https://garv-shah.github.io/brain/js/util.6f22941e242efae60fd84e7c32e874fa.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script async src=https://garv-shah.github.io/brain/js/popover.f03552ccb84d99ca615d1cfb9abde59e.min.js></script>
<script defer src=https://garv-shah.github.io/brain/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://garv-shah.github.io/brain/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://garv-shah.github.io/brain/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://garv-shah.github.io/brain",fetchData=Promise.all([fetch("https://garv-shah.github.io/brain/indices/linkIndex.cc5cd1239fae153beed7a1fc46418153.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://garv-shah.github.io/brain/indices/contentIndex.243ded72c19065a503517f39ad047f22.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://garv-shah.github.io/brain",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://garv-shah.github.io/brain",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/garv-shah.github.io\/brain\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://garv-shah.github.io/brain/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://garv-shah.github.io/brain>ðŸ‘‹ Garv's Notes</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Graph Algorithms</h1><p class=meta>Last updated
May 18, 2023
<a href=https://github.com/garv-shah/notes/tree/hugo/content/notes/School%20Subjects/Algorithmics/Graph%20Algorithms.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#breadth-first-search-bfs-card>Breadth First Search (BFS) #card</a></li><li><a href=#depth-first-search-dfs-card>Depth First Search (DFS) #card</a></li><li><a href=#applications-of-dfs-and-bfs-card>Applications of DFS and BFS #card</a></li><li><a href=#graph-colouring-card>Graph Colouring #card</a></li><li><a href=#detecting-cycles-card>Detecting Cycles #card</a></li><li><a href=#topological-sorting-card>Topological Sorting #card</a></li><li><a href=#shortest-path-in-unweighted-graphs-card>Shortest Path in Unweighted Graphs #card</a></li><li><a href=#spanning-tree-card>Spanning Tree #card</a></li><li><a href=#prims-algorithm-card>Prim&rsquo;s Algorithm #card</a></li><li><a href=#dijkstras-algorithm-card>Dijkstra&rsquo;s Algorithm #card</a></li><li><a href=#bellman-ford-algorithm-card>Bellman-Ford Algorithm #card</a></li><li><a href=#dijkstras-vs-bellman-ford-vs-floyd-warshall-card>Dijkstra&rsquo;s vs Bellman-Ford vs Floyd-Warshall #card</a></li></ol></nav></details></aside><p>#algo</p><a href=#breadth-first-search-bfs-card><h2 id=breadth-first-search-bfs-card><span class=hanchor arialabel=Anchor># </span>Breadth First Search (BFS) #card</h2></a><p>BFS is a graph traversal algorithm that visits all neighbours of a source node, and keeps visiting neighbours of neighbours until the entire graph is traversed.
<strong>BFS algorithm step-by-step</strong></p><ol><li>Add the initial node to theÂ <strong>queue</strong>Â and mark it asÂ <strong>seen</strong>.</li><li>Remove the next element from theÂ <strong>queue</strong>Â and call itÂ <strong>current</strong>.</li><li>Get all neighbours of theÂ <strong>current</strong>Â node that are not yet marked asÂ <strong>seen</strong>.</li><li>Store all these neighbours into theÂ <strong>queue</strong>Â and mark them all asÂ <strong>seen</strong>.</li><li>Repeat stepsÂ <strong>2 - 4</strong>Â until theÂ <strong>queue</strong>Â becomes empty.
<a class="internal-link broken">Graph Algorithms.png</a>
^1684293406145</li></ol><a href=#depth-first-search-dfs-card><h2 id=depth-first-search-dfs-card><span class=hanchor arialabel=Anchor># </span>Depth First Search (DFS) #card</h2></a><p>DFS is a graph traversal algorithm that chooses any single neighbour node for each discovered node and proceeds searching from it. This produces long branches, because searching from other neighbours is only carried out once a branch has been fully explored.</p><ul><li>Design Pattern: Decrease & Conquer âˆµ grows MST by cheapest edge possible that does not make a cycle
<strong>DFS algorithm step-by-step</strong></li></ul><ol><li>Add the initial node to theÂ <strong>stack</strong>.</li><li>Remove the next element from theÂ <strong>stack</strong>Â and call itÂ <strong>current</strong>.</li><li>If theÂ <strong>current</strong>Â node wasÂ <strong>seen</strong>Â then skip it (go to stepÂ <strong>6</strong>).</li><li>Otherwise mark theÂ <strong>current</strong>Â node asÂ <strong>seen</strong>.</li><li>Get all neighbours of theÂ <strong>current</strong>Â node and add all of them to theÂ <strong>stack</strong>.</li><li>Repeat stepsÂ <strong>2 - 5</strong>Â until theÂ <strong>stack</strong>Â becomes empty.
<strong>Difference from BFS</strong></li></ol><ul><li>We use aÂ <strong>stack</strong>Â instead of theÂ <strong>queue</strong>Â for storing nodes.</li><li>Typically we do not check whether a node wasÂ <strong>seen</strong>Â when storing neighbours in the stackÂ â€“ instead we perform this checking when retrieving the node from it.
^1684293406148</li></ul><a href=#applications-of-dfs-and-bfs-card><h2 id=applications-of-dfs-and-bfs-card><span class=hanchor arialabel=Anchor># </span>Applications of DFS and BFS #card</h2></a><ul><li>DFS and BFS will both give information about whether one node is connected to another via any path in a graph.</li><li>If the graphÂ <strong>is</strong>Â connected, BFS will visit all of its nodes.</li><li>The traversal tree built by BFS represents the shortest paths from the initial vertex to any other for an unweighted graph.</li><li>DFS is unsuitable for searching shortest paths for unweighted graphs.
^1684293406149</li></ul><a href=#graph-colouring-card><h2 id=graph-colouring-card><span class=hanchor arialabel=Anchor># </span>Graph Colouring #card</h2></a><p>Graph colouring or vertex colouring is the process of colouring a graph such that no adjacent vertices have the same colour. A $k$-colouring of a graph uses $k$ colours, and the chromatic number is the minimum value of $k$ for which a $k$ colouring exists.
Applications are generally to resolve conflicts, where certain objects cannot be next to each other or certain events cannot run at the same time.
These generally end up being <strong>optimal resource allocation</strong> problems.
^1684293406150</p><a href=#detecting-cycles-card><h2 id=detecting-cycles-card><span class=hanchor arialabel=Anchor># </span>Detecting Cycles #card</h2></a><p>DFS is used to detect cycles! With a small modification to DFS to maintain a list of visited nodes as well as processed nodes, DFS can detect cycles, and if a we visit a node we have already visited, a cycle is detected.
^1684293406151</p><a href=#topological-sorting-card><h2 id=topological-sorting-card><span class=hanchor arialabel=Anchor># </span>Topological Sorting #card</h2></a><p>The DFS order of the processed list is the topological sorting, normally run from a source node.
One problem that can be solved by divide and conquer is topological sorting.Â <strong>Topological sorting</strong>Â is the ordering of information according to its dependencies and is typically represented by a directed graph showing the order of progress for a particular system.
^1684293406152</p><a href=#shortest-path-in-unweighted-graphs-card><h2 id=shortest-path-in-unweighted-graphs-card><span class=hanchor arialabel=Anchor># </span>Shortest Path in Unweighted Graphs #card</h2></a><p>BFS is used to find the shortest path in unweighted graphs from one node to another. By rippling out in layers from the starting node, it can find the first path to the end node.
^1684293406153</p><a href=#spanning-tree-card><h2 id=spanning-tree-card><span class=hanchor arialabel=Anchor># </span>Spanning Tree #card</h2></a><p>AÂ <strong>spanning tree</strong>Â is a connected graph that has no circuits or cycles and which includes all the vertices or nodes of a graph.
AÂ <strong>minimum spanning tree</strong>Â (MST) is a spanning tree for a weighted graph whose edges add up to the smallest possible value.
^1684293406154</p><a href=#prims-algorithm-card><h2 id=prims-algorithm-card><span class=hanchor arialabel=Anchor># </span>Prim&rsquo;s Algorithm #card</h2></a><p><strong>Prim&rsquo;s Algorithm</strong> is a greedy algorithm used for finding the MST in weighted undirected graphs.</p><ul><li>Design Pattern: Marks each processed node and reduces problem sizer by one node in each iteration until all nodes processed
<strong>Prim&rsquo;s algorithm in plain English</strong></li></ul><ol><li>Begin at any vertex.</li><li>Select theÂ <strong>cheapest</strong>Â (minimum-weight)Â edge emanating from the vertex.</li><li>Look at edges coming from the vertices selected so far: select theÂ cheapestÂ edge; if the edge forms a circuit, discard it and select the next cheapest.</li><li>Repeat until all vertices have been selected.</li><li>Double-check by repeating the process with a different starting vertex.
^1684293406155</li></ol><a href=#dijkstras-algorithm-card><h2 id=dijkstras-algorithm-card><span class=hanchor arialabel=Anchor># </span>Dijkstra&rsquo;s Algorithm #card</h2></a><p>Dijkstra&rsquo;s algorithm finds the shortest path from the starting location to any other location, not just the desired destination. The algorithm works on weighted graphs and weighted digraphs,Â <strong>where no negative weight cycles exist.</strong>
Dijkstra&rsquo;s algorithm is aÂ <strong>greedy</strong>Â algorithmÂ â€“ that is, one that starts at a given source node in a weighted graph and expands all possible paths from this node using the weights on the edges to all the immediate neighbours. It then repeats this process from the cheapest-cost neighbour at this point in the algorithm.Â 
As it calculates the shortest path, it marks nodes that have been explored and expanded to their immediate neighbours as &lsquo;visited&rsquo; until all the nodes in the graph have been explored, processed, expanded and visited.
When all nodes have been processed, the shortest path from the source node will have been calculated for all the other nodes in the graph.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>While there are unvisited vertices do
</span></span><span class=line><span class=cl>  find the vertex (V) with the smallest distance in the unvisited vertices list
</span></span><span class=line><span class=cl>  remove V from the unvisited vertices list
</span></span><span class=line><span class=cl>  for each neighbour (N) of vertex V do
</span></span><span class=line><span class=cl>    thisDist:=distance to V plus the weight of the edge V-N
</span></span><span class=line><span class=cl>    if thisDist &lt; distance to N then
</span></span><span class=line><span class=cl>      A shorter path to N has been found
</span></span><span class=line><span class=cl>      Update the shortest path to N distance to N := thisDist
</span></span><span class=line><span class=cl>      set the shortest path predecessor to N as V
</span></span><span class=line><span class=cl>^1684293406156
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    End if
</span></span><span class=line><span class=cl>  End do
</span></span><span class=line><span class=cl>End do
</span></span></code></pre></td></tr></table></div></div><a href=#bellman-ford-algorithm-card><h2 id=bellman-ford-algorithm-card><span class=hanchor arialabel=Anchor># </span>Bellman-Ford Algorithm #card</h2></a><p>Bellman-Ford, like Dijkstra&rsquo;s uses relaxation to find the shortest path, but it can also <em>detect</em> that a negative cycle exists. It will not be able to find the shortest path if this cycle exists. This being said, Bellman-Ford <em>works</em> on graphs with negative edge weights, but not negative cycles.
<strong>Unlike Dijkstraâ€™s algorithm, the Bellman-Ford algorithm is not greedy and does not use a priority queue to process the edges.</strong>
^1684293406157</p><a href=#dijkstras-vs-bellman-ford-vs-floyd-warshall-card><h2 id=dijkstras-vs-bellman-ford-vs-floyd-warshall-card><span class=hanchor arialabel=Anchor># </span>Dijkstra&rsquo;s vs Bellman-Ford vs Floyd-Warshall #card</h2></a><ul><li>Dijkstra&rsquo;s: shortest path from <strong>one</strong> node to all nodes</li><li>Bellman-Ford: shortest path from <strong>one</strong> node to all nodes, negative edges <strong>allowed</strong></li><li>Floyd-Warshall&rsquo;s Shortest Path: shortest path between <strong>all</strong> pairs of vertices, negative edges allowed
Negative cycles are not allowed in any of these algorithms, because shortest path doesn&rsquo;t make sense for negative cycles.
^1684293406158</li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://garv-shah.github.io/brain/js/graph.2d9e48dbe7ea47c0ef1c58296ce14448.js></script></div></div><div id=contact_buttons><footer><p>Made by Garv Shah using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=https://garv-shah.github.io/brain>Home</a></li><li><a href=https://www.linkedin.com/in/garvshah/>LinkedIn</a></li><li><a href=https://github.com/garv-shah>GitHub</a></li></ul></footer></div></div></body></html>