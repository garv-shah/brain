<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="I will start and end my day at my house, picking up all my friends along the way. The algorithm will find the quickest route to go to all my friends&rsquo; houses, go to our desired location(s), and drop them all off before I go back to my own house."><title>Algorithmics SAT - Friendship Network</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://garv-shah.github.io/brain/icon.png><link href=https://garv-shah.github.io/brain/styles.547fb332ce56cdc523146ba5ede80d7f.min.css rel=stylesheet><link href=https://garv-shah.github.io/brain/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://garv-shah.github.io/brain/js/darkmode.d2f9c03bc6718238c95256784ad55a40.min.js></script>
<script src=https://garv-shah.github.io/brain/js/util.6f22941e242efae60fd84e7c32e874fa.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script async src=https://garv-shah.github.io/brain/js/popover.f03552ccb84d99ca615d1cfb9abde59e.min.js></script>
<script defer src=https://garv-shah.github.io/brain/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://garv-shah.github.io/brain/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://garv-shah.github.io/brain/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://garv-shah.github.io/brain",fetchData=Promise.all([fetch("https://garv-shah.github.io/brain/indices/linkIndex.5038f1122ca6dab24d23539aead4c2a9.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://garv-shah.github.io/brain/indices/contentIndex.eaba56f1a197b91130fbb9c8f7c0be54.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://garv-shah.github.io/brain",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://garv-shah.github.io/brain",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/garv-shah.github.io\/brain\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://garv-shah.github.io/brain/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://garv-shah.github.io/brain>ðŸ‘‹ Garv's Notes</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Algorithmics SAT - Friendship Network</h1><p class=meta>Last updated
Jun 2, 2022
<a href=https://github.com/garv-shah/notes/tree/hugo/content/notes/School%20Subjects/Algorithmics/SAT/Garv%27s%20SAT-%20Friendship%20Network.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#information-to-consider>Information to Consider</a><ol><li><a href=#node-representation>Node Representation</a></li><li><a href=#edge-representation>Edge Representation</a></li><li><a href=#weight-representation>Weight Representation</a></li><li><a href=#additional-information-modelled-outside-graph>Additional Information Modelled Outside Graph</a></li></ol></li><li><a href=#abstract-data-types>Abstract Data Types</a></li><li><a href=#possible-graph>Possible Graph</a></li><li><a href=#signatures>Signatures</a></li><li><a href=#algorithm-selection>Algorithm Selection</a><ol><li><a href=#held-karp-algorithm>Held-Karp algorithm</a></li><li><a href=#dijkstras-algorithm>Dijkstra&rsquo;s Algorithm</a></li></ol></li><li><a href=#optimisations>Optimisations</a><ol><li><a href=#caching-dijkstras-output>Caching Dijkstra&rsquo;s Output</a></li><li><a href=#caching-held-karps-output>Caching Held-Karp&rsquo;s Output</a></li></ol></li></ol></nav></details></aside><p>I will start and end my day at my house, picking up all my friends along the way. The algorithm will find the quickest route to go to all my friends&rsquo; houses, go to our desired location(s), and drop them all off before I go back to my own house. It will then return to me the traversal path, the time taken, and my cost for transport throughout the day.</p><a href=#information-to-consider><h2 id=information-to-consider><span class=hanchor arialabel=Anchor># </span>Information to Consider</h2></a><p>The following is key information to consider when modelling the real life problem. This will be done by representing the problem with an undirected network/graph, as all public transport methods go both ways, just at different times depending on the transport method.</p><a href=#node-representation><h3 id=node-representation><span class=hanchor arialabel=Anchor># </span>Node Representation</h3></a><p>Nodes represent key landmarks such as train stations, bus stops or a tourist attraction.</p><a href=#edge-representation><h3 id=edge-representation><span class=hanchor arialabel=Anchor># </span>Edge Representation</h3></a><p>Edges represent a route (train, bus, tram, walking, etc) from one location to another</p><a href=#weight-representation><h3 id=weight-representation><span class=hanchor arialabel=Anchor># </span>Weight Representation</h3></a><p>The edge weights will represent:</p><ul><li>the time taken to travel from one house to the other</li><li>the financial cost of the route, with buses being more expensive than trains, which are more expensive than walking, etc. These can be interchanged to prioritise the certain attribute, such as time or money being of higher importance in the algorithm.</li></ul><a href=#additional-information-modelled-outside-graph><h3 id=additional-information-modelled-outside-graph><span class=hanchor arialabel=Anchor># </span>Additional Information Modelled Outside Graph</h3></a><p>The following would be modelled as dictionaries:</p><ul><li>The arrival time/timetable of buses and trains</li><li>The cost of changing lines</li><li>Attributes of each friend, such as name, home, the time they wake up, the amount of time they take to get ready, and who is friends with whom or to what degree.</li><li>Proximity to all friends&rsquo; houses (by walking), which would be a dictionary for each node separately. This information could be used to add further complications to make the model reflect real life more closely, such as different friends being ready earlier than others or requiring a certain number of &ldquo;close friends&rdquo; (by threshold) to be within the travel party at all times.</li></ul><a href=#abstract-data-types><h2 id=abstract-data-types><span class=hanchor arialabel=Anchor># </span>Abstract Data Types</h2></a><p>I have selected a number of stations, bus stops and locations which I feel are relevant to my friend group.</p><table><thead><tr><th>Property</th><th>Stored as</th><th>Notes</th></tr></thead><tbody><tr><td>Key Landmarks</td><td>Node</td><td></td></tr><tr><td>Landmark Name</td><td>Node Attribute</td><td></td></tr><tr><td>Route</td><td>Edge</td><td></td></tr><tr><td>Route Name</td><td>Edge Attribute</td><td></td></tr><tr><td>Transport Method/Line</td><td>Edge Colour</td><td></td></tr><tr><td>Time or Cost</td><td>Edge Weight</td><td>These can be interchanged to prioritise different aspects. Distance is more relevant than time, but cost may be important as well.</td></tr><tr><td>Time/Cost of Changing Lines</td><td>Node attribute &ldquo;interchange_cost&rdquo; & &ldquo;interchange_time&rdquo;</td><td></td></tr><tr><td>Train and Bus Timetable</td><td>Dictionary: DictÂ«String: ArrayÂ«DictÂ«String: Int or StringÂ»Â»Â»</td><td>Keys would be each line (bus or train), and the values would be arrays of dictionaries with what node they are at, arrival times and departure times.</td></tr><tr><td>Attributes of Each Friend</td><td>Dictionary: DictÂ«String: DynamicÂ»</td><td>This will be a json style nested dictionary that has various attributes about each friend, such as waking up time, other close friends and other relevant information</td></tr><tr><td>Proximity to Friends&rsquo; Houses</td><td>Node Attribute: DictÂ«String: FloatÂ»</td><td>Proximity of all houses as an attribute for each node, which has keys as friends&rsquo; names and values as the distance or time to their house</td></tr></tbody></table><a href=#possible-graph><h2 id=possible-graph><span class=hanchor arialabel=Anchor># </span>Possible Graph</h2></a><hr><p><img src="https://github.com/garv-shah/brain/blob/hugo/content/notes/Attachments/Algorithmics/Possible%20Friendship%20Network.png?raw=true" width=auto alt="Possible Graph" title="Possible Graph"></p><a href=#signatures><h2 id=signatures><span class=hanchor arialabel=Anchor># </span>Signatures</h2></a><table><thead><tr><th>Function Name</th><th>Signature</th></tr></thead><tbody><tr><td>addLandmark</td><td>[name, interchange_cost, friend_proximity] -> node</td></tr><tr><td>addRoute</td><td>[start_node, end_node, travel_method, time, cost] -> edge</td></tr><tr><td>findShortestPath</td><td>[start_node, end_node] -> integer, array</td></tr><tr><td>addFriend</td><td>[name, wake_time, close_friends] -> dictionary</td></tr></tbody></table><a href=#algorithm-selection><h2 id=algorithm-selection><span class=hanchor arialabel=Anchor># </span>Algorithm Selection</h2></a><p>While simplifying my problem, I found that starting and ending my day at my house while picking up all my friends along the way is simply an applied version of finding the shortest hamiltonian circuit. In other words, the shortest cost circuit that will visit every node.</p><p>While researching into how to solve this, I found that this was a classic example of the travelling salesman problem, which turns out to be an NP-hard problem. This means that there currently exists no exact solution to the problem in polynomial time, and the best I can currently do is the Heldâ€“Karp algorithm, which has a time complexity of $O(n^{2}2^{n})$ which is not ideal at all in terms of efficiency, but will have to be sufficient for the use cases of this project.</p><a href=#held-karp-algorithm><h3 id=held-karp-algorithm><span class=hanchor arialabel=Anchor># </span>Held-Karp algorithm</h3></a><p>The Held-Karp algorithm is a method for finding the exact shortest hamiltonian circuit in the exponential time complexity of $O(n^{2}2^{n})$, which is much better than if we to brute force it, which would have a complexity of $O(n!)$.</p><p>It works by utilising the fact the following principle.</p><p>Let $A =$ starting vertex
Let $B =$ ending vertex
Let $S = {P, Q, R}$ or any other vertices to be visited along the way.
Let $C \in S$</p><p>We $\therefore$ know that $\textrm{Cost}<em>{\textrm{min}} \space A \rightarrow B \space \textrm{whilst visiting all nodes in S}$ = $\textrm{min}(\textrm{Cost} \space A \rightarrow C \space \textrm{visiting everything else in S} + d</em>{CB})$. Put more simply, we can find the smallest cost hamiltonian path by gradually building larger and larger subpaths from the minimum cost to the next node in $S$, using dynamic programming to combine the subpaths to form the larger hamiltonian path.</p><p>This logic leads to the following pseudocode:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. function held_karp (
</span></span><span class=line><span class=cl>2. 	start: node, 
</span></span><span class=line><span class=cl>3. 	end: node, 
</span></span><span class=line><span class=cl>4. 	visit: set&lt;node&gt;
</span></span><span class=line><span class=cl>5. ):
</span></span><span class=line><span class=cl>6. 	if visit.size = 0:
</span></span><span class=line><span class=cl>7. 		return dist(start, end)
</span></span><span class=line><span class=cl>8. 	else:
</span></span><span class=line><span class=cl>9. 		min = infinity
</span></span><span class=line><span class=cl>10. 		For node C in set S:
</span></span><span class=line><span class=cl>11. 			sub_path = held_carp(start, C, (set \ C))
</span></span><span class=line><span class=cl>12. 			cost = sub_path + dist(C, end)
</span></span><span class=line><span class=cl>13. 			if cost &lt; min:
</span></span><span class=line><span class=cl>14. 				min = cost
</span></span><span class=line><span class=cl>15. 		return min
</span></span><span class=line><span class=cl>16. end function
</span></span></code></pre></td></tr></table></div></div><p>After being implemented in Python (with a slight modification to return the path as well), this pseudocode looks like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>held_karp</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>visit</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>visit</span><span class=p>)</span> <span class=ow>is</span> <span class=ow>not</span> <span class=nb>set</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Error: visit must be a set of nodes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s1>&#39;cost&#39;</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>),</span> <span class=s1>&#39;path&#39;</span><span class=p>:</span> <span class=kc>None</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>visit</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s1>&#39;cost&#39;</span><span class=p>:</span> <span class=n>dist</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>),</span> <span class=s1>&#39;path&#39;</span><span class=p>:</span> <span class=p>[</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>]}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>minimum</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;cost&#39;</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>rand_node</span> <span class=ow>in</span> <span class=n>visit</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>sub_path</span> <span class=o>=</span> <span class=n>held_karp</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>rand_node</span><span class=p>,</span> <span class=n>visit</span><span class=o>.</span><span class=n>difference</span><span class=p>({</span><span class=n>rand_node</span><span class=p>}))</span>
</span></span><span class=line><span class=cl>            <span class=n>cost</span> <span class=o>=</span> <span class=n>dist</span><span class=p>(</span><span class=n>rand_node</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span> <span class=o>+</span> <span class=n>sub_path</span><span class=p>[</span><span class=s1>&#39;cost&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>cost</span> <span class=o>&lt;</span> <span class=n>minimum</span><span class=p>[</span><span class=s1>&#39;cost&#39;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>minimum</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;cost&#39;</span><span class=p>:</span> <span class=n>cost</span><span class=p>,</span> <span class=s1>&#39;path&#39;</span><span class=p>:</span> <span class=n>sub_path</span><span class=p>[</span><span class=s1>&#39;path&#39;</span><span class=p>]</span> <span class=o>+</span> <span class=p>[</span><span class=n>end</span><span class=p>]}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>minimum</span>
</span></span></code></pre></td></tr></table></div></div><p>The problem with this implementation is that it currently only works with complete graphs, where the distance between any two given nodes will not be infinity. This becomes clear if we try and find the cost of going from Oakleigh to Melbourne Central while visiting Caulfield along the way. The pseudocode would choose Caulfield as the value for $C$, as it is the only node in the set. The issue is at line <code>12</code>, as the algorithm would try and get the distance between Caulfield and Melbourne Central, but as there is no edge between these two nodes, it will return $\infty$.</p><p>This can be solved by using <a href=/brain/notes/School-Subjects/Algorithmics/SAT/Garvs-SAT-Friendship-Network#dijkstrarsquos-algorithm rel=noopener class=internal-link data-src=/brain/notes/School-Subjects/Algorithmics/SAT/Garvs-SAT-Friendship-Network>Dijkstra&rsquo;s Algorithm</a>, instead of the <code>dist</code> function, which will instead find the shortest path (and $\therefore$ distance) between any two given nodes.</p><p>After this modification, our hybrid algorithm works great!</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Let&#39;s say I have 5 friends, they live closest to the following nodes: Caulfield, Mount Waverley, Glen Waverley, Melbourne Central and Chadstone
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The following would be the fastest path to go from my house (Brandon Park) to all my friends&#39; and back:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{&#39;cost&#39;: 182, &#39;path&#39;: [&#39;Brandon Park&#39;, &#39;Wheelers Hill Library&#39;, &#39;CGS WH&#39;, &#39;Glen Waverley&#39;, &#39;Mount Waverley&#39;, &#39;Richmond&#39;, &#39;Parliament&#39;, &#39;Melbourne Central&#39;, &#39;Flinders Street&#39;, &#39;Caulfield&#39;, &#39;Chadstone&#39;, &#39;Oakleigh&#39;, &#39;Brandon Park&#39;]}
</span></span></code></pre></td></tr></table></div></div><a href=#dijkstras-algorithm><h3 id=dijkstras-algorithm><span class=hanchor arialabel=Anchor># </span>Dijkstra&rsquo;s Algorithm</h3></a><p>Dijkstra&rsquo;s Algorithm is a method for finding the shortest path between any two given nodes in a weighted graph, given that the weights are non-negative. If some of the weights were negative, the Bellman-Ford Algorithm could also be used to find the shortest path between two vertices, but as this is not the case for our model (a method of transport cannot take you negative time to get somewhere), Dijkstra&rsquo;s Algorithm is preferred for simplicity.</p><p>Dijkstra&rsquo;s Algorithm is a greedy algorithm, which actually finds the distance between a node and every other node on the graph. It does this based on the notion that if there were a shorter path than any sub-path, it would replace that sub-path to make the whole path shorter. More simply, shortest paths must be composed of shortest paths, which allows Dijkstra&rsquo;s to be greedy, always selecting the shortest path from &ldquo;visited&rdquo; nodes, using the principle of relaxation to gradually replace estimates with more accurate values.</p><p>Dijkstra&rsquo;s Algorithm follows the logic outlined by the following pseudocode:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. function dijkstras (
</span></span><span class=line><span class=cl>2. 	start: node, 
</span></span><span class=line><span class=cl>3. 	end: node,
</span></span><span class=line><span class=cl>4. 	graph: graph
</span></span><span class=line><span class=cl>5. ):
</span></span><span class=line><span class=cl>6. 	// Set all node distance to infinity
</span></span><span class=line><span class=cl>7. 	for node in graph:
</span></span><span class=line><span class=cl>8. 		distance[node] = infinity
</span></span><span class=line><span class=cl>9. 		predecessor[node] = null
</span></span><span class=line><span class=cl>10. 		unexplored_list.add(node)
</span></span><span class=line><span class=cl>11. 		
</span></span><span class=line><span class=cl>12. 	distance[start] = 0
</span></span><span class=line><span class=cl>13. 	
</span></span><span class=line><span class=cl>14. 	while unexplored_list is not empty:
</span></span><span class=line><span class=cl>15. 		min_node = unexplored node with min cost
</span></span><span class=line><span class=cl>16. 		unexplored_list.remove(min_node)
</span></span><span class=line><span class=cl>17. 		
</span></span><span class=line><span class=cl>18. 		for each neighbour of min_node:
</span></span><span class=line><span class=cl>19. 			current_dist = distance[min_node] + dist(min_node, neighbour)
</span></span><span class=line><span class=cl>20. 			// a shorter path has been found to the neighbour -&gt; relax value
</span></span><span class=line><span class=cl>21. 			if current_dist &lt; distance[neighbour]:
</span></span><span class=line><span class=cl>22. 				distance[neighbour] = current_dist
</span></span><span class=line><span class=cl>23. 				predecessor[neighbour] = min_node
</span></span><span class=line><span class=cl>24. 	
</span></span><span class=line><span class=cl>25. 	return distance[end]
</span></span><span class=line><span class=cl>26. end function
</span></span></code></pre></td></tr></table></div></div><p>After being implemented in Python (with a slight modification to return the path as well), the pseudocode looks like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># set all nodes to infinity with no predecessor</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span> <span class=o>=</span> <span class=p>{</span><span class=n>node</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>g</span><span class=o>.</span><span class=n>nodes</span><span class=p>()}</span>
</span></span><span class=line><span class=cl>    <span class=n>predecessor</span> <span class=o>=</span> <span class=p>{</span><span class=n>node</span><span class=p>:</span> <span class=kc>None</span> <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>g</span><span class=o>.</span><span class=n>nodes</span><span class=p>()}</span>
</span></span><span class=line><span class=cl>    <span class=n>unexplored</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>g</span><span class=o>.</span><span class=n>nodes</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>distance</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>unexplored</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>min_node</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>unexplored</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>node</span><span class=p>:</span> <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>unexplored</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>min_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbour</span> <span class=ow>in</span> <span class=n>g</span><span class=o>.</span><span class=n>neighbors</span><span class=p>(</span><span class=n>min_node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>current_dist</span> <span class=o>=</span> <span class=n>distance</span><span class=p>[</span><span class=n>min_node</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>(</span><span class=n>min_node</span><span class=p>,</span> <span class=n>neighbour</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># a shorter path has been found to the neighbour -&gt; relax value</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current_dist</span> <span class=o>&lt;</span> <span class=n>distance</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>distance</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>=</span> <span class=n>current_dist</span>
</span></span><span class=line><span class=cl>                <span class=n>predecessor</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>=</span> <span class=n>min_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># reconstructs the path</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span> <span class=o>=</span> <span class=p>[</span><span class=n>end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=n>start</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>predecessor</span><span class=p>[</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s1>&#39;cost&#39;</span><span class=p>:</span> <span class=n>distance</span><span class=p>[</span><span class=n>end</span><span class=p>],</span> <span class=s1>&#39;path&#39;</span><span class=p>:</span> <span class=n>path</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#optimisations><h2 id=optimisations><span class=hanchor arialabel=Anchor># </span>Optimisations</h2></a><p>The optimisations below were created after the following base case:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Let&#39;s say I have 9 friends, they live closest to the following nodes: {&#39;Mount Waverley&#39;, &#39;Melbourne Central&#39;, &#39;Chadstone&#39;, &#39;CGS WH&#39;, &#39;Parliament&#39;, &#39;Wheelers Hill Library&#39;, &#39;Flinders Street&#39;, &#39;Brighton Beach&#39;, &#39;Camberwell&#39;}
</span></span><span class=line><span class=cl>The following would be the fastest path to go from my house (Brandon Park) to all my friends&#39; and back:
</span></span><span class=line><span class=cl>{&#39;cost&#39;: 262, &#39;path&#39;: [&#39;Brandon Park&#39;, &#39;Wheelers Hill Library&#39;, &#39;CGS WH&#39;, &#39;Glen Waverley&#39;, &#39;Mount Waverley&#39;, &#39;Richmond&#39;, &#39;Camberwell&#39;, &#39;Richmond&#39;, &#39;Parliament&#39;, &#39;Melbourne Central&#39;, &#39;Flinders Street&#39;, &#39;Brighton Beach&#39;, &#39;Flinders Street&#39;, &#39;Caulfield&#39;, &#39;Chadstone&#39;, &#39;Oakleigh&#39;, &#39;Brandon Park&#39;]}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>It took 47.3621 seconds to run.
</span></span></code></pre></td></tr></table></div></div><p>As seen, running the above Held-Karp + Dijkstra&rsquo;s combination took about 50 seconds to calculate the minimal cost path for 9 nodes. The following is a table for $n \space \textrm{vs} \space t$, with an approximate line of best fit of $y \approx a \times b^{x}$ where $a=8.1017\times10^{-8}$ and $b=9.3505$:</p><table><thead><tr><th>$n$ (no. nodes)</th><th>$t$ (execution time in seconds, 4dp)</th><th>$y$ (line of best fit, 4dp)</th></tr></thead><tbody><tr><td>0</td><td>0.0001</td><td>0.0000</td></tr><tr><td>1</td><td>0.0002</td><td>0.0000</td></tr><tr><td>2</td><td>0.0002</td><td>0.0000</td></tr><tr><td>3</td><td>0.0016</td><td>0.0001</td></tr><tr><td>4</td><td>0.0083</td><td>0.0006</td></tr><tr><td>5</td><td>0.0132</td><td>0.0058</td></tr><tr><td>6</td><td>0.1090</td><td>0.0541</td></tr><tr><td>7</td><td>0.5674</td><td>0.5063</td></tr><tr><td>8</td><td>4.7193</td><td>4.7343</td></tr><tr><td>9</td><td>44.2688</td><td>44.2680</td></tr></tbody></table><p>Anything above 7 nodes takes far too long, and calculating the entire hamiltonian circuit would take 5 weeks 1 day 14 hours 56 mins and 39 secs based on the line of best fit, so the following optimisations have been utilised.</p><a href=#caching-dijkstras-output><h3 id=caching-dijkstras-output><span class=hanchor arialabel=Anchor># </span>Caching Dijkstra&rsquo;s Output</h3></a><p>When replacing the <code>dist</code> function with Dijkstra&rsquo;s Algorithm, a certain time compromise was made. <code>dist</code> has a time complexity of $O(1)$, simply fetching the distance from the distance matrix, but Dijkstra&rsquo;s Algorithm is relatively slower at $O(E\log{V})$ where $E$ is the number of edges and $V$ the number of vertices. For our sample graph above, with $E = 27$ and $V = 15$, $O(E\log{V}) \approx 31.75$. This makes using Dijkstra&rsquo;s roughly 31 times slower than <code>dist</code>as it is called every time.</p><p>To avoid this, we can cache the results of Dijkstra&rsquo;s Algorithm to avoid running the same calculation multiple times. This can be done with the following pseudocode:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. cached_djk = dictionary of node -&gt; dict
</span></span><span class=line><span class=cl>2. 
</span></span><span class=line><span class=cl>3. function fetch_djk (
</span></span><span class=line><span class=cl>4. 	start: node, 
</span></span><span class=line><span class=cl>5. 	end: node, 
</span></span><span class=line><span class=cl>6. ):
</span></span><span class=line><span class=cl>7. 	if cached_djk[start] does not exists:
</span></span><span class=line><span class=cl>8. 		cached_djk[start] = dijkstras(start)
</span></span><span class=line><span class=cl>9. 	
</span></span><span class=line><span class=cl>10. 	djk = cached_djk[start]
</span></span><span class=line><span class=cl>11. 	# reconstructs the path  
</span></span><span class=line><span class=cl>12. 	path = [end] as queue  
</span></span><span class=line><span class=cl>13. 	while path.back != start:  
</span></span><span class=line><span class=cl>14. 		path.enqueue(djk[&#39;predecessors&#39;][path.back])
</span></span><span class=line><span class=cl>15. 	
</span></span><span class=line><span class=cl>16. 	return {
</span></span><span class=line><span class=cl>17. 		&#39;distance&#39;: djk[&#39;distances&#39;][end], 
</span></span><span class=line><span class=cl>18. 		&#39;path&#39;: path
</span></span><span class=line><span class=cl>19. 	}
</span></span><span class=line><span class=cl>20. end function
</span></span></code></pre></td></tr></table></div></div><p>In this case, <code>dijkstras</code> would need to be modified to return the <code>distance</code> and <code>predecessor</code> rather than just <code>distance[end]</code>.</p><p>After being implemented in Python, <code>cached_djk</code> resembles the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fetch_djk</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>start</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>cached_djk</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>cached_djk</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=n>dijkstra</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>djk</span> <span class=o>=</span> <span class=n>cached_djk</span><span class=p>[</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=c1># reconstructs the path</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span> <span class=o>=</span> <span class=p>[</span><span class=n>end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=n>start</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>djk</span><span class=p>[</span><span class=s1>&#39;predecessors&#39;</span><span class=p>][</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s1>&#39;cost&#39;</span><span class=p>:</span> <span class=n>djk</span><span class=p>[</span><span class=s1>&#39;distances&#39;</span><span class=p>][</span><span class=n>end</span><span class=p>],</span> <span class=s1>&#39;path&#39;</span><span class=p>:</span> <span class=n>path</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#performance-improvement><h4 id=performance-improvement><span class=hanchor arialabel=Anchor># </span>Performance Improvement</h4></a><p>As expected by the theoretical time savings calculated above, this optimisation makes Held-Karp roughly 31 times faster. The base case from above, which took 44 - 47 seconds before the optimisation now only takes about 1.25 seconds.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Let&#39;s say I have 9 friends, they live closest to the following nodes: {&#39;Parliament&#39;, &#39;Melbourne Central&#39;, &#39;Chadstone&#39;, &#39;Camberwell&#39;, &#39;Flinders Street&#39;, &#39;Brighton Beach&#39;, &#39;Mount Waverley&#39;, &#39;CGS WH&#39;, &#39;Wheelers Hill Library&#39;}
</span></span><span class=line><span class=cl>The following would be the fastest path to go from my house (Brandon Park) to all my friends&#39; and back:
</span></span><span class=line><span class=cl>{&#39;cost&#39;: 262, &#39;path&#39;: [&#39;Brandon Park&#39;, &#39;Wheelers Hill Library&#39;, &#39;CGS WH&#39;, &#39;Glen Waverley&#39;, &#39;Mount Waverley&#39;, &#39;Richmond&#39;, &#39;Camberwell&#39;, &#39;Richmond&#39;, &#39;Parliament&#39;, &#39;Melbourne Central&#39;, &#39;Flinders Street&#39;, &#39;Brighton Beach&#39;, &#39;Flinders Street&#39;, &#39;Caulfield&#39;, &#39;Chadstone&#39;, &#39;Oakleigh&#39;, &#39;Brandon Park&#39;]}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>It took 1.2799 seconds to run.
</span></span></code></pre></td></tr></table></div></div><p>The $n \space \textrm{vs} \space t$ table now looks like this, with an approximate line of best fit of $y \approx a \times b^{x}$ where $a=1.4002\times10^{-9}$ and $b=10.1876$:</p><table><thead><tr><th>$n$ (no. nodes)</th><th>$t$ (execution time in seconds, 4dp)</th><th>$y$ (line of best fit, 4dp)</th></tr></thead><tbody><tr><td>0</td><td>0.0001</td><td>0.0000</td></tr><tr><td>1</td><td>0.0001</td><td>0.0000</td></tr><tr><td>2</td><td>0.0001</td><td>0.0000</td></tr><tr><td>3</td><td>0.0001</td><td>0.0000</td></tr><tr><td>4</td><td>0.0001</td><td>0.0000</td></tr><tr><td>5</td><td>0.0005</td><td>0.0002</td></tr><tr><td>6</td><td>0.0060</td><td>0.0016</td></tr><tr><td>7</td><td>0.0287</td><td>0.0159</td></tr><tr><td>8</td><td>0.2148</td><td>0.1625</td></tr><tr><td>9</td><td>1.6055</td><td>1.6551</td></tr><tr><td>10</td><td>17.4555</td><td>16.8620</td></tr><tr><td>11</td><td>171.6719</td><td>171.7832</td></tr><tr><td>12</td><td>1750.1065</td><td>1750.0590</td></tr></tbody></table><p>We can see that this line of best fit is relatively accurate, and if we extend it to run for 14 nodes (our hamiltonian circuit), it would take a total of about 2 days 2 hours 27 mins and 14 secs to compute it all.</p><a href=#caching-held-karps-output><h3 id=caching-held-karps-output><span class=hanchor arialabel=Anchor># </span>Caching Held-Karp&rsquo;s Output</h3></a><p>The same principle as above can be applied to the Held-Karp algorithm. Although it is a harder task to make Held-Karp iterative, the result of computations can be stored rather than calling <code>held_karp</code> every time. As above, this can be done with an intermediary function, <code>fetch_hk</code> which only runs <code>held_karp</code> if the value hasn&rsquo;t already been stored.</p><p>The pseudocode for this process is relatively simple:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cached_hk = dictionary of list -&gt; dict
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function fetch_hk (
</span></span><span class=line><span class=cl>	start: node, 
</span></span><span class=line><span class=cl>	end: node,
</span></span><span class=line><span class=cl>	visit: set of nodes 
</span></span><span class=line><span class=cl>):
</span></span><span class=line><span class=cl>	if cached_hk[[start, end, visit]] does not exists:
</span></span><span class=line><span class=cl>		cached_hk[[start, end, visit]] = held_karp(start, end, visit)
</span></span><span class=line><span class=cl>	return cached_hk[[start, end, visit]]
</span></span><span class=line><span class=cl>end function
</span></span></code></pre></td></tr></table></div></div><p>After being implemented in Python, <code>fetch_hk</code> resembles the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fetch_hk</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>visit</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>key</span> <span class=o>=</span> <span class=nb>frozenset</span><span class=p>([</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=nb>frozenset</span><span class=p>(</span><span class=n>visit</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>key</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>cached_hk</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>cached_hk</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>held_karp</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>visit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cached_hk</span><span class=p>[</span><span class=n>key</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><a href=#performance-improvement-1><h4 id=performance-improvement-1><span class=hanchor arialabel=Anchor># </span>Performance Improvement</h4></a><p>Though this is a somewhat minor change, the improvements are drastic, with the entire hamiltonian circuit being calculated in less than a second. The $n \space \textrm{vs} \space t$ table now looks like this, with an approximate line of best fit of $y \approx a \times b^{x}$ where $a=0.00000544325$ and $b=2.36503$:</p><table><thead><tr><th>$n$ (no. nodes)</th><th>$t$ (execution time in seconds, 4dp)</th><th>$y$ (line of best fit, 4dp)</th></tr></thead><tbody><tr><td>0</td><td>0.0001</td><td>0.0000</td></tr><tr><td>1</td><td>0.0001</td><td>0.0000</td></tr><tr><td>2</td><td>0.0001</td><td>0.0000</td></tr><tr><td>3</td><td>0.0001</td><td>0.0001</td></tr><tr><td>4</td><td>0.0001</td><td>0.0002</td></tr><tr><td>5</td><td>0.0002</td><td>0.0004</td></tr><tr><td>6</td><td>0.0005</td><td>0.0010</td></tr><tr><td>7</td><td>0.0012</td><td>0.0023</td></tr><tr><td>8</td><td>0.0030</td><td>0.0053</td></tr><tr><td>9</td><td>0.0081</td><td>0.0126</td></tr><tr><td>10</td><td>0.0210</td><td>0.0298</td></tr><tr><td>11</td><td>0.0520</td><td>0.0705</td></tr><tr><td>12</td><td>0.2051</td><td>0.1667</td></tr><tr><td>13</td><td>0.5061</td><td>0.3942</td></tr><tr><td>14</td><td>0.8246</td><td>0.9323</td></tr><tr><td>15</td><td>2.2284</td><td>2.2050</td></tr></tbody></table><p>Evidently this is significantly better, with Held-Karp at 12 nodes being about 8,533 times faster than without this optimisation. Across a couple tests, the $b$ value of the line of best fit seems to hover around $2.1-2.3$, which indicates that we&rsquo;re nearing the limits of our optimisations. The theoretical average time complexity of Held-Karp is $O(2^{n}n^{2})$, and it is unknown if any algorithm exists to solve TSP in a time complexity of less than base 2. As such, the closer we get to base 2, the more &ldquo;perfectly&rdquo; we have optimised our algorithm, and as of now we&rsquo;re pretty close.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/brain/notes/School-Subjects/Algorithmics/SAT/Garvs-SAT-Friendship-Network/ data-ctx="Dijkstra's Algorithm" data-src=/notes/School-Subjects/Algorithmics/SAT/Garvs-SAT-Friendship-Network class=internal-link>Algorithmics SAT - Friendship Network</a></li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://garv-shah.github.io/brain/js/graph.2d9e48dbe7ea47c0ef1c58296ce14448.js></script></div></div><div id=contact_buttons><footer><p>Made by Garv Shah using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=https://garv-shah.github.io/brain>Home</a></li><li><a href=https://www.linkedin.com/in/garvshah/>LinkedIn</a></li><li><a href=https://github.com/garv-shah>GitHub</a></li></ul></footer></div></div></body></html>